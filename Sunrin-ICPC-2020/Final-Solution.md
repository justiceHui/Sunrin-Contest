# 2020 천하제일 코딩대회 본선 풀이

### A번

(1) 현재 시간에 처리할 정보, (2) 다음 시간에 처리할 정보를 각각 큐로 관리하면서 문제에서 시키는 대로 BFS를 하면 됩니다.

BFS를 하면서 빈 칸을 모두 방문했다면 마지막으로 방문한 시간을, 빈칸을 모두 방문하기 전에 BFS가 종료되었다면 -1을 출력하면 됩니다.

### B번

어떤 칸 (r, c)에 잠복할 수 있는 조건은 다음과 같습니다.

1. (r, c)가 빈 칸('.')이다.
2. (r, c)를 장애물('@')로 바꿨을 때, (r, c)가 속한 공간이 두 개 이상으로 분할된다.

즉, 2차원 평면에서의 단절점을 찾는 문제입니다.

정점 개수가 적기 때문에, 모든 빈 칸을 하나씩 장애물로 바꿔보면서 해당 칸이 속한 공간이 두 개 이상으로 분할되는지 확인하면 됩니다.

### C번

**족보의 힘**을 사용해서 정점 몇 개가 합쳐졌을 때 트리의 지름을 빠르게 구하는 문제입니다.

해야하는 작업은 다음과 같습니다.

1. 두 정점의 LCA 구하기
2. **족보의 힘**을 사용했을 때 합쳐지는 정점 처리
3. 일부 정점이 합쳐진 트리에서 지름 구하기

트리의 높이가 O(log N)이기 때문에 LCA를 Naive하게 구해도 O(log N)에 구할 수 있습니다.

**족보의 힘을 사용했을 때 합쳐지는 정점을 처리해봅시다.**

l ~ r번째 리프를 합치는 상황을 생각해봅시다. 합쳐지는 정점을 모두 구하는 것보다는 필요 없는 정점을 제거하는 것이 편합니다. LCA(l, r)을 루트로 하는 서브 트리에서 필요 없는 정점을 제거하면 됩니다.

필요 없는 정점은 다음 과정을 통해 제거할 수 있습니다.

1. l에서 LCA(l, r)까지 부모 정점을 따라 올라가면서, l의 왼쪽 자식이 합쳐지는지 확인
2. r에서 LCA(l, r)까지 부모 정점을 따라 올라가면서, r의 오른쪽 자식이 합쳐지는지 확인

l, r의 왼쪽, 오른쪽 자식 정점이 합쳐지지 않는다면, 해당 정점을 루트로 하는 서브 트리 전체가 포함되지 않습니다.

**S(v) = v를 루트로 하는 서브 트리의 가중치 합**을 미리 계산해놓으면, 합쳐진 정점의 가중치를 빠르게 구할 수 잇습니다.

**일부 정점이 합쳐진 트리에서 지름을 구해봅시다.**

합쳐진 정점 U는 지름에 무조건 포함시킵시다.

U를 기준으로 (1) 왼쪽, (2) 오른쪽, (3) 위에 서브트리가 있을 수 있습니다.<br>트리의 지름(∈ 경로)는 두 점을 잇는 것이기 때문에 (1), (2), (3) 중 가장 작지 않은 값(= 1, 2번째로 큰 값)을 U에 더한 것이 트리의 지름이 됩니다.

**D(v) = v에서 리프노트까지 내려가는 경로 중 가중치의 최댓값**을 미리 구해놓으면 비교적 쉽게 처리할 수 있습니다.

### D번

```cpp
#include <stdio.h>

int main(){
    int K, D, A;
    scanf("%d/%d/%d", &K, &D, &A);
    if(K+A < D || D == 0) printf("hasu");
    else printf("gosu");
}
```

### E번

15의 배수는 3의 배수인 동시에 5의 배수인 수입니다.<br>5의 배수는 마지막 자리가 0 또는 5인 수이며, 3의 배수는 각 자리 수의 합이 3의 배수인 수입니다. 두 조건이 성립하는 수의 개수를 구하면 됩니다.

마지막 자리에는 5 밖에 올 수 없기 때문에, 나머지 N-1자리를 적절히 배정해서 3의 배수로 만들면 됩니다.<br>즉, N-1개의 합을 3으로 나눈 나머지가 1이 되도록 만들면 됩니다.

1을 a개, 5를 b개 사용한다고 합시다. 아래 두 조건을 만족해야 합니다.

1. a + b = N-1
2. (a + 5b)를 3으로 나눈 나머지가 1 = (a + 2b)를 3으로 나눈 나머지가 1

(a, b)가 두 조건을 만족한다면, N-1개 중 a개는 0을 배정하고, 나머지는 1로 배정하면 됩니다.<br>N-1개 중 a개를 고르는 경우는 (N-1)Ca 입니다. 두 조건을 만족하는 모든 (a, b) 쌍에 대해 (N-1)Ca 의 합을 구해서 출력하면 됩니다.

### F번

친구 관계를 그래프로 모델링합시다. a, b와 동시에 이웃한 정점의 개수를 구하면 됩니다.<br>이를 구하는 가장 간단한 풀이는, A[a, i]와 A[b, i]가 동시에 1인 i를 세는 것입니다.

이 풀이는 시간 복잡도가 O(NQ)로 시간 초과를 받게 됩니다. 이 풀이를 최적화 해봅시다.

N이 32 이하라면 한 사람의 친구 관계를 int형(32비트 정수) 변수 하나로 관리할 수 있습니다. 이때 a, b와 동시에 이웃한 정점은 두 정수에 and 연산을 취한 값에서 켜진 비트의 개수가 됩니다.

그러므로 친구 관계를 N/32개의 int형 변수로 관리해주면 연산량을 32배 줄일 수 있습니다. long long형(64비트 정수)을 사용하면 64배 줄일 수 있습니다.

이런 테크닉을 bitset이라고 부릅니다. 시간 복잡도는 O(NQ/64)가 됩니다.

C/C++에서 gcc 컴파일러를 쓰는 경우, 정수 자료형에서 켜진 비트의 개수를 빠르게 구해주는 함수가 있어, 이 함수를 이용하면 편하게 구현할 수 있습니다. int형은 `__builtin_popcount`, long long형은 `__builtin_popcountll`을 사용하면 됩니다.

### G번

배열 A[i]를 키워드 i를 포함하는 컨텐츠의 번호라고 정의합시다.

각 배열의 원소를 잘 정렬해서 출력하면 됩니다.

### H번

주어진 문제를 반대로 생각해서, Xi들이 주어졌을 때 MST를 구하는 문제를 생각해봅시다.

28번째 비트가 켜져있는 정점들의 집합과 꺼져있는 정점들의 집합을 잇는 간선은 하나만 존재하는 것이 최적입니다. 정점 집합을 28번째 비트에 따라서 분할합시다.

28번째 비트에 따라 분할된 각 집합 안에서, 27번째 비트가 켜져있는 정점들의 집합과 꺼져있는 정점들의 집합을 잇는 간선은 하나만 존재하는 것이 최적입니다. 이 정점 집합을 다시 27번째 비트에 따라서 분할합니다.

위 과정을 반복하는 것으로 MST를 구할  수 있습니다.<br>이 풀이를 응용해 MST가 주어졌을 때 Xi를 복원하는 방법을 생각해봅시다.

f(T, D)를 트리 T의 각 정점을 2^(D+1) 미만의 수로 채우는 함수라고 합시다.

T에서 적당한 간선 (u, v)를 잡아서 끊으면 트리가 두 개로 분할됩니다. 분할된 각 트리를 T1, T2라고 합시다.<br>아래 과정을 거쳐 Xi를 복원할 수 있습니다.

1. T1에 속한 정점의 D번째 비트를 0으로 설정
2. T2에 속한 정점의 D번째 비트를 1로 설정
3. f(T1, D-1)과 f(T2, D-1)을 각각 재귀적으로 호출
4. 두 트리 T1과 T2를 분할하는 간선 (u, v)가 T1과 T2를 연결하는 최소 가중치 간선이 되도록 T1과 T2의 각 정점에 적절한 값을 xor

트리의 degree가 3 이하라면 아래 조건을 만족하는 간선 e가 반드시 존재한다고 합니다.

* e를 제거해서 만들어진 트리를 T1, T2, 각 트리에 속한 정점의 개수를 S1, S2라고 할 때
* S2 ≤ 2 × S1 + 1, S1 ≤ 2 × S2 + 1

이 조건 덕분에 분할 정복은 최대 28단계 안에 작동합니다.

### I번

함수의 호출 관계는 방향 그래프로 표현할 수 있습니다.

모든 함수를 호출하기 위해 호출해야하는 함수의 최소 개수는 **in-degree가 0인 SCC의 개수**와 동일합니다.

테스트 케이스로 주어진 T개의 함수가 in-degree가 0인 SCC를 모두 커버하는지 확인하면 됩니다.<br>모두 커버한다면 in-degree가 0인 SCC의 개수를, 모두 커버하지 않는다면 -1을 출력하면 됩니다.

### J번

입력으로 주어진 수를 A0 A1 A2 ... A(n-1)이라고 합시다.<br>Ai가 답에 얼마나 기여하는지 알면 문제의 정답을 구할 수 있습니다. 구체적으로, Ai가 1의 자리가 되는 경우의 수, 10의 자리가 되는 경우의 수, 100의 자리가 되는 경우의 수, ...를 구하면 됩니다.

Ai가 10^r자리가 되는 경우의 수는 다음과 같이 계산할 수 있습니다.

* Ai보다 뒤에 있는 n-i-1개의 수는 정확히 r개 포함해야 합니다. 이런 경우의 수는 (n-i-1)Cr입니다.
* Ai보다 앞에 있는 i개의 수는 포함 여부를 고려할 필요가 없습니다. 2^i 가지 경우의 수를 모두 포함하며 됩니다.
* 그러므로 Ai가 10^r자리가 되는 경우의 수는 2^i × (n-i-1)Cr입니다.

Ai는 답에 2^i × sum((n-i-1)Cr)만큼 기여하게 됩니다. 이때 r는 0부터 n-i-1까지의 정수입니다.<br>이항 정리에 의해 sum((n-i-1)Cr)은 11^(n-i-1)이 됩니다.

따라서 Ai는 답에 Ai × 2^i × 11^(n-i-1)만큼 기여합니다.

모든 i에 대해 구해서 더해주면 됩니다.

### K번

"각 정점이 LCA가 되는 경우의 수"를 구하면 답은 쉽게 구할 수 있습니다.

정점 v가 LCA가 되는 경우의 수는 (v를 루트로 하는 서브 트리의 크기)^2 - sum( (v의 i번째 자식을 루트로 하는 서브 트리의 크기)^2 )입니다.